32 32-bit registers

r0 - hard-wired to 0
...
r31

register aliases:
r31 - lr - link register
r30 - sp - stack pointer
r29 - fp - frame pointer

instruction encoding:
register type  (r-type): opcode, reg1, reg2, reg3, alu_opcode, pad0
immediate type (i-type): opcode, reg1, reg2, immediate value

opcode     - 6 bits
reg        - 5 bits
alu_opcode - 6 bits
immediate  - 16 bits
pad0       - 5 bits

opcode == 0, r-type instruction
opcode  > 0, i-type instruction

alu_opcode:
0 - add
1 - sub
2 - and
3 - or
4 - xor
5 - nor
6 - sll
7 - srl
8 - sra
9 - mul
10 - div

// note: mul and div currently support only signed arithmetic and store the result only in 32 bits;
// they take 33 cycles to execute, all other instructions take 1 cycle


i-type instructions (by opcode):

1)  beq reg1, reg2, imm    // imm is an absolute address of the program memory
2)  bne ...
3)  blt     // less than
4)  bltu    // less than unsigned
5)  ble     // less equal
6)  bleu
7)  bgt     // greater
8)  bgtu
9)  bge     // greater equal
10) bgeu

11) b imm   // unconditional branch

12) ldr reg2, imm(reg1)    // reg2 = *(reg1 + imm); if reg2 is r0, then imm is an absolute address
13) str reg2, imm(reg1)    // *(reg1 + imm) = reg2

14) addi reg2, reg1, imm   // reg2 = reg1 + imm
15) andi ...
16) ori
17) xori
18) slli                   // shift left logical
19) srli                   // shift right logical
20) srai                   // shift right arithmetic
21) muli
22) divi


23) bl imm  // branch and link; reg2 must be set to lr
24) bx reg1 // branch exchange, sets pc to reg1

r-type instructions (opcode == 0):

add reg3, reg1, reg2   // reg3 = reg1 + reg2
sub ...
and
or
xor
nor                    // if reg2 is r0, reg3 = ~reg1
sll
srl
sra


immediate operands for logical instructions are zero extended, for arithmetic
they are sign extended (addi, muli, divi)
sign extension also happens for ldr and str instructions
